const N = 4;

// ld is an array where its indices indicate row-col+N-1
const ld = new Array(30).fill(0);

// rd is an array where its indices indicate row+col
const rd = new Array(30).fill(0);

// Column array where its indices indicate column
const cl = new Array(30).fill(0);

// A utility function to print solution
function printSolution(board) {
	for (let i = 0; i < N; i++) {
		for (let j = 0; j < N; j++) {
			process.stdout.write(board[i][j] === 1 ? ' Q ' : ' . ');
		}
		console.log();
	}
}

// A recursive utility function to solve N Queen problem
function solveNQUtil(board, col) {
	// Base case: If all queens are placed, return true
	if (col >= N) {
		return true;
	}

	// Consider this column and try placing this queen in all rows one by one
	for (let i = 0; i < N; i++) {
		// Check if the queen can be placed on board[i][col]
		if (ld[i - col + N - 1] !== 1 && rd[i + col] !== 1 && cl[i] !== 1) {
			// Place this queen in board[i][col]
			board[i][col] = 1;
			ld[i - col + N - 1] = rd[i + col] = cl[i] = 1;

			// Recur to place the rest of the queens
			if (solveNQUtil(board, col + 1)) {
				return true;
			}

			// If placing the queen in board[i][col] doesn't lead to a solution, backtrack
			board[i][col] = 0; // BACKTRACK
			ld[i - col + N - 1] = rd[i + col] = cl[i] = 0;
		}
	}

	// If the queen cannot be placed in any row in this column col, return false
	return false;
}

// This function solves the N Queen problem using Backtracking.
// It mainly uses solveNQUtil() to solve the problem.
// It returns false if queens cannot be placed, otherwise,
// returns true and prints placement of queens in the form of 1s.
// Please note that there may be more than one solution;
// this function prints one of the feasible solutions.
function solveNQ() {
	const board = new Array(N).fill(0).map(() => new Array(N).fill(0));

	if (!solveNQUtil(board, 0)) {
		console.log("Solution does not exist");
		return false;
	}

	printSolution(board);
	return true;
}

// Driver program to test above function
solveNQ();
